export = c
import = cparser

c:
	external_declaration+

punctuator: '%:%:' | '...' | '<<=' | '>>=' | '::' | '->' | '++' | '--' | '&=' | '##' | '*=' | '+=' | 
    '-=' | '/=' | '%=' | '<=' | '>=' | '>>' | '==' | '!=' | '^=' | '||' | '&&' | '|=' | 
    '<<' | '<:' | ':>' | '<%' | '%>' | '%:' | ';' | '=' | '*' | '/' | '%' | '+'  | '-' | '>' | '&' | '^' | '|' | ',' | '#' | 
    '<' | '[' | ']' | '(' | ')' | '{' | '}' | '.' | '~' | '!' | '?' | ':'

keyword:
      'alignas'         /* C23 (macro pre-C23) */
    | 'alignof'         /* C23 (macro pre-C23) */
	| 'asm' 			// standard C extension (see Annex J). used by gcc, etc.
	| 'auto'  
    | 'bool'			/* C23 (macro pre-C23) */
	| 'break' 
    | 'case' 
    | 'char' 
	| 'constexpr'		// C23
    | 'const'
    | 'continue' 
    | 'default'
    | 'double'
	| 'do' 
    | 'else' 
    | 'enum' 
    | 'extern'
	| 'false' 
    | 'float'
	| 'for' 
    | 'goto' 
    | 'if' 
    | 'inline' 
	| 'int'
	| 'long' 
	| 'macro'
	| 'nullptr'			// C23
	| 'pragma'			// needed to capture pragma lines that survive pre-processing
	| 'register' 
    | 'restrict' 
    | 'return' 
    | 'short'
	| 'signed'
	| 'sizeof' 
	| 'static_assert'
    | 'static' 
    | 'struct' 
    | 'switch'
	| 'thread_local' 
    | 'true'
	| 'typedef'
	| 'typeof_unqual'
	| 'typeof' 			// gcc extension for pre-C23
    | 'union' 
    | 'unsigned'
    | 'void'
	| 'volatile'
    | 'while'
	| '_Alignas'
    | '_Alignof'
    | '_Atomic' 
	| '_BitInt'
	| '_Bool'
	| '_Complex'
	| '_Decimal32'
	| '_Decimal64'
	| '_Decimal128'
    | '_Generic' 
    | '_Imaginary' 
    | '_Noreturn' 
    | '_Static_assert'
    | '_Thread_local'
	| '__asm__' 		// gcc extension
	| '__asm' 			// msvc extension
	| '__based' 		// msvc extension
	| '__cdecl' 		// msvc extension
	| '__clrcall' 		// msvc extension
	| '__declspec' 		// msvc declaration-specifier extensions
	| '__extension__' 	// gcc extension to silence -pedantic: https://gcc.gnu.org/onlinedocs/gcc/Alternate-Keywords.html
	| '__fastcall' 		// msvc extension
	| '__inline__'		// gcc extension
	| '__inline' 		// msvc extension
	| '__int8' 			// msvc extension
	| '__int16' 		// msvc extension
	| '__int32' 		// msvc extension
	| '__int64' 		// msvc extension
	| '__restrict__' 	// gcc extension
	| '__stdcall' 		// msvc extension
	| '__thiscall' 	    // msvc extension
	| '__typeof__'		// gcc extension
	| '__vectorcall' 	// msvc extension
	| '__volatile__'    // gcc extension
    | '__attribute__'

token:
    whitespace | punctuator | constant | string_literal | identifier | keyword  // keyword is basically unreachable. whitespace is added to remove comments. It is skipped anyway

whitespace(skip_token):
    "([ \t\r\n\v\f]+|(\\\\\n)|(//[^\n]*\n)|(/\\*((\\*[^/])|[^*])*\\*/))+"

identifier:
	"([a-zA-Z_]|\\\\[uU]([0-9a-fA-F]{4}){1,2})(([a-zA-Z_0-9]|\\\\[uU]([0-9a-fA-F]{4}){1,2}))*"

identifier_nondigit:
	  nondigit
	| universal_character_name

digit:
    "[0-9]"

nondigit:
    "[a-zA-Z_]"

universal_character_name:
	""

// includes octal and hex integer constants
int_constant:
    "(([1-9][0-9]*)|(0(x|X)[A-Fa-f0-9]+)|(0[0-7]*))(((u|U)(l|L)?)|((l|L|LL|ll)(u|U)?))?"

hex_float_constant:
    "0(x|X)((([A-Fa-f0-9]*\\.[A-Fa-f0-9]+)|([A-Fa-f0-9]+\\.))|([A-Fa-f0-9]+))p[-+]?[0-9]+(f|l|F|L)?"

decimal_float_constant:
    "(((([0-9]*\\.[0-9]+)|([0-9]+\\.))([eE][-+]?[0-9]+)?)|([0-9]+[eE][-+]?[0-9]+))(f|l|F|L)?"

float_constant:
    decimal_float_constant | hex_float_constant

enum_constant:
    identifier

char_prefix:
	"[LuU]?'"

char_suffix:
	"'"

single_c_char:
	"[^'\\\\\n]"

simple_escape_sequence:
	"\\\\['\"?\\abfnrtv]"

octal_escape_sequence:
	"\\([0-7]{1,3})"

hexadecimal_escape_sequence:
	"\\x([0-9a-fA-F]+)"

escape_sequence:
	  simple_escape_sequence
	| octal_escape_sequence
	| hexadecimal_escape_sequence
	| universal_character_name

c_char:
	  single_c_char
	| escape_sequence

char_constant:
    char_prefix, c_char+, char_suffix

constant:
    float_constant | int_constant | char_constant | enum_constant

// check to make sure the inner double quotes work
string_literal:
    "(u8|u|U|L)?\"((\\\\\")|[^\"])*\"" // this is literally everything between two double quotes including escaped double quotes



// EXPRESSIONS

primary_expression:
	  identifier // constant enum_specifier will never fire when this is first, so any enum resolution must be handled here
	| constant
	| string_literal
	| '(', expression, ')'
	| generic_selection

generic_selection:
	'_Generic', '(', assignment_expression, ',', ','.generic_association, ')'

generic_association:
	(type_name | 'default'), ':', assignment_expression

postfix_expression:
	(primary_expression | compound_literal),    ( '[', expression, ']'
												| '(', ','.assignment_expression?, ')'
												| '.', identifier
												| '->', identifier
												| '++'
												| '--'
												)*

compound_literal:
	'(', storage_class_specifier*, type_name, ')', '{', initializer_list, ','?, '}'

unary_expression:
	  'sizeof', unary_expression // right-recursive
	| 'sizeof', '(', type_name, ')'
	| '_Alignof', '(', type_name, ')'
	| 'alignof', '(', type_name, ')'
	|  postfix_expression // postfix_expression can be matched by an identifier so sizeof/_Alignof operators must come first
	| '++', unary_expression
	| '--', unary_expression
	| unary_operator, cast_expression

unary_operator:
	  '&'
	| '*'
	| '+'
	| '-'
	| '~'
	| '!'

cast_expression:
	  '(', type_name, ')', cast_expression
	| unary_expression

multiplicative_expression(simplify_binary_op):
	cast_expression, (('*' | '/' | '%'), cast_expression)*

additive_expression(simplify_binary_op):
	multiplicative_expression, (('+' | '-'), multiplicative_expression)*

shift_expression(simplify_binary_op):
	additive_expression, (('<<' | '>>'), additive_expression)*
	
relational_expression(simplify_binary_op):
	shift_expression, (('<' | '>' | '<=' | '>='), shift_expression)*
	
equality_expression(simplify_binary_op):
	relational_expression, (('==' | '!='), relational_expression)*
	
AND_expression(simplify_binary_op):
	equality_expression, ('&', equality_expression)*
	
XOR_expression(simplify_binary_op):
	AND_expression, ('^', AND_expression)*
	
OR_expression(simplify_binary_op):
	XOR_expression, ('|', XOR_expression)*

logAND_expression(simplify_binary_op):
	OR_expression, ('&&', OR_expression)*

logOR_expression(simplify_binary_op):
	logAND_expression, ('||', logAND_expression)*
	
conditional_expression:
	  logOR_expression, '?', expression, ':', conditional_expression
	| logOR_expression

assignment_expression:
	  unary_expression, assignment_operator, assignment_expression
	| conditional_expression

assignment_operator:
	  '='
	| '*='
	| '/='
	| '%='
	| '+='
	| '-='
	| '<<='
	| '>>='
	| '&='
	| '^='
	| '|='

expression:
	','.assignment_expression
	
constant_expression:
	conditional_expression

// DECLARATIONS

declaration(c_process_declaration):
	(  declaration_specifiers, ','.init_declarator?
	 | attribute_specifier+, declaration_specifiers, ','.init_declarator
	 | static_assert_declaration
	 | attribute_specifier+), ';' // attribute_declaration in spec

declaration_specifiers(c_process_declaration_specifiers):
	declaration_specifier+

// placement of msattribute: https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2010/zxk0tw93(v=vs.100)?redirectedfrom=MSDN
declaration_specifier:
	  storage_class_specifier
	| type_qualifier
	| function_specifier
	| alignment_specifier
	| attribute_specifier
	| gcc_attribute_specifier // compiler declaration_specifier extensions: https://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.html
	| msdeclspec
	| msattribute
	| type_specifier // ensures typedef is evaluated last

init_declarator:
	declarator, gcc_attribute_specifier*, ('=', initializer)?

storage_class_specifier:
	  'auto'
	| 'constexpr'
	| 'extern'
	| 'register'
	| 'static'
	| '_Thread_local'
	| 'thread_local'
	| 'typedef'

type_specifier: // cannot be mixed with another type specifier
	  'void'
	| 'char'
	| 'short'
	| 'int'
	| '__int8' // msvc extension
	| '__int16' // msvc extension
	| '__int32' // msvc extension
	| '__int64' // msvc extension
	| 'long'
	| 'float'
	| 'double'
	| 'signed'
	| 'unsigned' 
	| '_Bool' 
	| 'bool'  
	| '_BitInt', '(', constant_expression, ')'
	| '_Complex'
	| '_Decimal32'
	| '_Decimal64'
	| '_Decimal128'
	| atomic_type_specifier
	| struct_or_union_specifier
	| enum_specifier
	| typeof_specifier
	| typedef_name

msattribute:
	  '__asm'
	| '__based'
	| '__cdecl'
	| '__clrcall'
	| '__fastcall'
	| '__inline'
	| '__stdcall'
	| '__thiscall'
	| '__vectorcall'

// non_paren and paren_block to accommodate arbitrary gcc and msvc declaration specifier attribute syntax
non_paren:
	"[^\\()]+"
	
paren_block:
	'(', non_paren*, paren_block?, non_paren*, ')'

gcc_attribute_specifier: // gcc specific declaration_specifiers
	'__attribute__', paren_block
	| '__extension__'	

msdeclspec: // msvc specific declaration_specifiers
	'__declspec', '(', identifier*,')'

struct_or_union_specifier:
	  struct_or_union, attribute_specifier*, identifier?, '{', member_declaration+, '}'
	| struct_or_union, attribute_specifier*, identifier

struct_or_union:
	'struct' | 'union'

member_declaration:
	  attribute_specifier*, specifier_qualifier_list, ','.member_declarator?, gcc_attribute_specifier*, ';'
	| static_assert_declaration, ';'

specifier_qualifier_list:
	(type_specifier_qualifier | gcc_attribute_specifier)+, attribute_specifier*

type_specifier_qualifier:
	  type_specifier
	| type_qualifier
	| alignment_specifier

member_declarator:
	  declarator?, ':', constant_expression
	| declarator

enum_specifier:
	  'enum', attribute_specifier*, identifier?, enum_type_specifier?, '{', ','.enumerator, ','?, '}'
	| 'enum', identifier, enum_type_specifier?

enumerator:
	  enum_constant, attribute_specifier*, '=', constant_expression
	| enum_constant, attribute_specifier*

enum_type_specifier:
	':', specifier_qualifier_list

atomic_type_specifier:
	'_Atomic', '(', type_name, ')'

typeof_specifier:
	  'typeof', '(', typeof_specifier_argument, ')'
	| 'typeof_unqual', '(', typeof_specifier_argument, ')'

typeof_specifier_argument:
	expression | type_name

type_qualifier:
	  'const'
	| 'volatile'
	| '__volatile__' // gcc extension
	| 'restrict'
	| '__restrict__' // gcc extension
	| '_Atomic'
	
function_specifier:
	  'inline' 
	| '__inline__' // gcc extension
	| '__inline' // also gcc extension
	| '_Noreturn' 
	
alignment_specifier:
	  ('_Alignas' | 'alignas'), '(', type_name, ')'
	| ('_Alignas' | 'alignas'), '(', constant_expression, ')'

declarator:
	pointer?, direct_declarator

direct_declarator: 
	(gcc_attribute_specifier*, identifier, attribute_specifier* | '(', declarator, ')'), (array_declarator | function_declarator)*
	
array_declarator:
	'[', (  type_qualifier*, assignment_expression?
		  | 'static', type_qualifier*, assignment_expression
		  | type_qualifier*, 'static', assignment_expression
		  | type_qualifier*, '*'), ']', attribute_specifier*

function_declarator:
	'(', parameter_type_list?, ')', attribute_specifier*

pointer:
	('*', attribute_specifier*, (type_qualifier | gcc_attribute_specifier)*)+ // gcc_attribute_specifier for the poorly described gcc-specific attributes

parameter_type_list:
	  ','.parameter_declaration, ',', '...'
	| ','.parameter_declaration
	| '...'

parameter_declaration:
	  attribute_specifier*, declaration_specifiers, declarator
	| attribute_specifier*, declaration_specifiers, abstract_declarator
	| attribute_specifier*, declaration_specifiers

type_name: // since abstract_declarator does not have an identifier, this should not pose an ambiguity issue for typedef_name & identifier
	specifier_qualifier_list, abstract_declarator?

abstract_declarator:
	  pointer
	| pointer?, direct_abstract_declarator

direct_abstract_declarator:
	  ('(', abstract_declarator, ')')?, (array_abs_declarator | function_abs_declarator)+
	| '(', abstract_declarator, ')'
	

array_abs_declarator:
	'[', (  type_qualifier*, assignment_expression?
		  | 'static', type_qualifier*, assignment_expression
		  | type_qualifier*, 'static', assignment_expression
		  | '*'), ']', attribute_specifier*

function_abs_declarator:
	'(', parameter_type_list?, ')', attribute_specifier*
	
// the negative lookahead handles type inference for the typedef-identifier ambiguity
typedef_name(c_check_typedef):
	//identifier
	identifier, !(attribute_specifier*, '=')
	
initializer:
	assignment_expression | '{', initializer_list?, ','?, '}'

initializer_list:
	','.(designation?, initializer)

designation:
	designator+, '='

designator:
	  '[', constant_expression, ']'
	| '.', identifier
	
static_assert_declaration:
	  ('static_assert' | '_Static_assert'), '(', constant_expression, ',', string_literal, ')'
	| ('static_assert' | '_Static_assert'), '(', constant_expression, ')'

attribute_specifier:
	'[', '[', ','.attribute?, ']', ']'

attribute:
	attribute_token, attribute_argument_clause

attribute_token:
	  identifier
	| attribute_prefixed_token

attribute_prefixed_token:
	identifier, '::', identifier

attribute_argument_clause:
	'(', balanced_token*, ')'

non_par_brk_bra:
	"[^\\(\\[\\{)]}]+"

balanced_token:
	  ('(' | '[' | '{'), balanced_token*, ('}', ']', ')')
	| non_par_brk_bra

// STATEMENTS

// I do not know why the hell they broke up the statement types as they did in C23. C11 was very straightforward. Rewrote C23 as below like C11
statement:
	  asm_statement // gcc (only?) extension. grammar at https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html
	| labeled_statement
	| attribute_specifier*, compound_statement
	| attribute_specifier*, selection_statement
	| attribute_specifier*, iteration_statement
	| attribute_specifier*, jump_statement
	| expression_statement 

asm_statement:
	('asm' | '__asm__'), asm_qualifiers*, paren_block

asm_qualifiers:
	'volatile' | '__volatile__' | '__inline__' | 'inline' | 'goto'

label:
	attribute_specifier*, (  identifier 
	                       | 'case', constant_expression
						   | 'default'), ':'

labeled_statement:
	label, statement

open_scope(_open_scope):
	'{'

close_scope(_close_scope):
	'}'

compound_statement:
	open_scope, block_item*, close_scope
		
block_item:
	statement | declaration | label
	
expression_statement:
	  expression?, ';'
	| attribute_specifier+, expression, ';'
	
selection_statement:
	  'if', '(', expression, ')', statement, ('else', statement)?
	| 'switch', '(', expression, ')', statement
	
iteration_statement:
	  'while', '(', expression, ')', statement
	| 'do', statement, 'while', '(', expression, ')', ';'
	| 'for', '(', (expression?, ';' | declaration), expression?, ';', expression?, ')', statement

jump_statement:
	(  'goto', identifier
	 | 'continue' 
	 | 'break' 
	 | 'return', expression?), ';'

external_declaration:
	  pragma_directive
	| function_definition
	| declaration
	| ';' // an empty line is apparently OK. Is this an extension? it is definitely not in the standard. string.h in Mingw64-gcc has it. ';' alone is a valid expression_statement, but cannot exist at file scope

function_definition:
	attribute_specifier*, declaration_specifiers, declarator, compound_statement

non_line_end:
	"[^\n]+"

pragma_directive:
	'#', 'pragma', non_line_end
	
